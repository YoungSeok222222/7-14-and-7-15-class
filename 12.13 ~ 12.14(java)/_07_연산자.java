public class _07_연산자 {
    public static void main(String[] args) {
        // 1. 연산자
        // 연산자: 연산을 수행하는 기호
        // 피연산자: 연산자의 연산 수행 대상

        // 3(피연산자) +(연산자) 5(피연산자)

        // "모든 연산자는 연산결과를 반환한다."
//===========================================================================================

// 2. 연산자의 종류
		/*
		 - 산술 연산자: + - * / % << >> (사칙 연산과 나머지 연산 %)
		 - 비교 연산자: > < >= <= == != (크고 작음과 같고 다름을 비교)
		 - 논리 연산자: && || ! & | ^ ~ ('그리고 AND'와 '또는 OR'으로 조건을 연결)
		 - 대입 연산자: =			      (우변의 값을 좌변에 저장)
		 - 기타 : (type) ?: instanceof (형변환 연산자, 삼항 연산자, instanceof 연산자)
		*/
//=====================================================================================

// 3. 연산자의 우선순위
        // "하나의 식(expression)에 연산자가 둘 이상 있을 때, 어떤 연산을 먼저 수행할지를 자동 결정하는 것"

		/*   종류	 결합규칙				연산자					우선순위
		 - 단항 연산자:   ←		 ++ -- + - ~ ! (type)			  높음←
		 - 산술 연산자:	→		 		* / %→
		 - 				→				+ -
		 - 				→				<< >>
		 - 비교 연산자:	→ 		< > <= >= instanceof
		 - 				→				== !=
		 - 논리 연산자:	→				  &
		 - 				→				  ^
		 - 				→				  |
		 - 				→				  &&
		 - 				→				  ||
		 - 삼항 연산자:	→				  ?:
		 - 대입 연산자: 	←  = += -= *= /= %= <<= >>= &= ^= |=	   낮음
		 */

        // "대입과 단항 연산자를 제외하면, 모두 왼쪽 -> 오른쪽"

//==================================================================

// !!정리!!

        // 연산자의 우선순위와 결합법칙은 "세 가지만 기억하자"

        // 1. 산술 > 비교 > 논리 > 대입. 대입은 제일 마지막에 수행된다.
        // 2. 단항(1) > 이항(2) > 삼항(3). 단항 연산자의 우선순위가 이항 연산자보다 높다.
        // 3. 단항 연산자와 대입 연산자를 제외한 모든 연산의 진행방향은 왼쪽에서 오른쪽이다.

//==================================================================================

// 4. 증감 연산자

        // 증감 연산자(++): 피연산자의 값을 1 증가시킨다.
        // 감소 연산자(--): 피연산자의 값을 1 감소시킨다.

        // 전위형: 값이 참조되기 전에 증가시킨다. ex) j = ++i;
        // 후위형: 값이 참조된 후에 증가시킨다.  ex) j = i++;

        // !!"증감 연산자가 독립적으로 사용된 경우, 전위형과 후위형의 차이가 없다."!!

        // 전위형: j = ++i;
        // ⇒ 1. ++i; (증가후에) 2. j = i; (참조하여 대입)

        // 후위형: j = i++;
        // ⇒ 1. 참조하여 대입 후에 2. i++; 증가


        int i = 5, j = 0;
        // j = i++;
        j = i; // 후위형
        i ++;
        System.out.println("j=i++; 실행후, i=" + i +", j=" + j);


        i = 5; // 결과를 비교하기 위해, i와 j의 값을 다시 5와 0으로 변경
        j = 0;

        // j = ++i;
        ++i; // 전위형
        j = i;
        System.out.println("j=++i; 실행후, i=" + i +", j=" + j);


// 4-1 부호 연산자(단항 연산자: 피연산자 1개)

        // -는 피연산자의 부호를 반대로 변경
        // +는 아무런 일도 하지 않는다.(실제 사용X)


// 4-2 형변환 연산자

        // 형변환이란, 변수 또는 상수의 타입을 다른 타입으로 변환하는 것 -> (타입)피연선자
        // "기존의 값을 최대한 보존할 수 있는 타입으로 자동 형변환된다."

        // 1byte   2byte   4byte   8byte   4byte    8byte
        // byte -> short -> int  -> long -> float -> double

        // 형변환은 큰 값에서 작은 값으로 형변환 할 때 써넣어줘야함 / 반대의 경우, 작은 값에서 큰 값으로 형변환하는 경우는 자동 형변환됨
        // ex)  double d = 85.4;
        // 		int score = (int)d;
        // 		int score = 85;

        // 자동 형변환
        float f = 1234; // int 타입의 값을 flaot타입의 변수에 저장
        float f1= (float)1234; // (자동형변환) 컴파일러가 자동으로 형변환
        // int i = 3.14f; ERROR 발생 => float가 더 큰 범위이기 때문에 값 손실 발생
        int iii = (int)3.14f; // OK 가능 => 수동 형변환


// 4-3 사칙 연산자 + - * /

        // 산술 변환: "연산 전에 피연산자의 타입을 일치시키는 것"
        // (1) 두 피연산자의 타입을 같게 일치시킨다. (보다 큰 타입으로 일치)
        // (2) 피연산자의 타입이 int보다 작은 타입이면 int로 변환된다.

        // 10
        int a = 1_000_000;	// 1백만 = 10의 6제곱
        int b = 2_000_000;	// 2백만 = 10의 6제곱

        // 10의 12제곱, int의 범위는 10의 9제곱.
        long c = (long)a * b; 	// a * b = 2,000,000,000,000 ?  둘 중에 하나만 long으로
//		long c = a * (long)b; 	// a * b = 2,000,000,000,000 ?

        System.out.println(c);
//===================================================================================

    }
}
